<?xml version="1.0" encoding="utf-8" ?>
<data>
    <learn-article-view>
        <section id="61" handle="articles">Articles</section>
        <entry id="64246">
            <audiences>
                <item handle="developers">Developers</item>
            </audiences>
            <author>
                <item id="9732">brendo</item>
            </author>
            <body mode="formatted"><h4>An Overview</h4>
<p>Symphony extension development has always been seen with an aura of 'dark arts' surrounding it, and now that Symphony 2.2 is here, it's a great time to take some steps to demystify this art. The purpose of this walkthrough is to provide an insight into how I built my <a href="http://github.com/brendo/field_metakeys">Meta Keys</a> extension. For those who haven't used it, the Meta Keys field allows a user to save key/value information against an Entry, without having to follow a defined schema. This walkthrough assumes you have an understanding of Symphony concepts and feel comfortable writing PHP.</p>
<h4>Getting Started</h4>
<h5>Directory Structure</h5>
<p><a href="http://www.flickr.com/photos/bloodbone/5423332863/"><img src="http://farm6.static.flickr.com/5298/5423332863_2218f68335.jpg" alt="Extension Directory Structure" /></a></p>
<p>The basis of any Symphony extension requires a certain directory structure to enable your extension to be discovered, and loaded by the Extension Manager. This absolute minimum for an extension is a folder, <code>field_metakeys</code>, with a single <code>extension.driver.php</code> file inside it. As this is a Field extension, I have then created a new <code>fields</code> directory containing a single file, <code>field.metakeys.php</code> in my extension root. All fields in Symphony live in <code>fields</code> folders and follow a <code>field.{handle}.php</code> convention. Naming conventions are everywhere in Symphony and some others that you may be familiar with is <code>events</code> and <code>event.{handle}.php</code>, or <code>data-sources</code> and <code>data.{handle}.php</code>. These all serve as a way for the Symphony Managers to load objects from the filesystem.</p>
<h4><code>extension.driver.php</code></h4>
<p>The extension driver contains your extension class that extends the Symphony base <code>Extension</code> class. It is vital that the name of your class starts with <code>extension_</code> followed by <strong>the same handle as your extension directory</strong>. So in Meta Key's case, this results in <a href="https://github.com/brendo/field_metakeys/blob/master/extension.driver.php#L3"><code>extension_field_metakeys</code></a>. The <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.extension.php">base <code>extension</code> class</a> is probably the best place to start to get an idea of what functions your extension driver should contain. </p>
<p>Generally, <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.extension.php#L121-138"><code>about()</code></a> is the first to be implemented and as the PHPDoc comments suggest, the purpose is to provide meta data about your extension such as the name, version, release data and author information. Symphony 2.2 allows you to provide multiple authors in your <code>about()</code> function by having an array of Author arrays. The <a href="http://symphony-cms.com/download/extensions/">Symphony website</a> allows Extensions to be searched by particular types, so it has become a bit of a pseudo convention for developers to create a comma separated list of these types for their <a href="https://github.com/brendo/field_metakeys/blob/master/extension.driver.php#L9">extension</a>.</p>
<p><a href="http://www.flickr.com/photos/bloodbone/5423935812/"><img src="http://farm6.static.flickr.com/5252/5423935812_c6738295af.jpg" alt="About Definition" /></a></p>
<h5>Installation</h5>
<p>The next functions of your <code>extension.driver.php</code> relate to the installation, updating and removal of your extension. For a Field extension, the installation function allows you to create a table schema to store any additional Symphony settings for your Field. There is a set of default Symphony settings, which are stored in the <code>sym_fields</code> table that all Fields will inherit (such as 'required', 'show_column' etc.), but you may wish to provide some additional settings for your Field. These settings can be customised by a developer when they create an instance of your Field in the Section Editor. </p>
<p>Your settings table should follow the convention of a Field extension, <code>sym_fields_{field-handle}</code> with the minimum columns of <code>id</code> and <code>field_id</code>. As a developer adds instances of your Field to their Symphony installation, a new row is created in this table for that instance of your extension (<code>field_id</code>) which allows a developer to add your extension to many sections, all with slightly different configurations. Remember, this table only stores setting information, as any entry data is stored in a separate table created by the Field's 'createTable()` function, but I'll get to that later. </p>
<p><a href="http://www.flickr.com/photos/bloodbone/5423382169/"><img src="http://farm6.static.flickr.com/5299/5423382169_d1487602f0.jpg" alt="Example Installation Query" /></a></p>
<p>The <code>uninstall</code> function needs to do the opposite to the <code>install</code> function, so in this case, drop the table that was just created. Finally, the <code>update</code> function can be used to help migrate your extension as you release new versions. Meta Keys is young so at the moment this just returns <code>true</code> as it has no migration to perform.</p>
<p>The Meta Keys installation (and uninstallation) queries are wrapped in a <code>try/catch</code> block, so that if anything happens, Meta Keys can report the error to the user through a Symphony <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.alert.php"><code>PageAlert</code></a>.</p>
<p>You may notice the prefix <code>sym_</code> on the table definition's. This prefix is an alias (or pseudonym) which is replaced by your actual databaseâ€™s table prefix at runtime which allows Symphony to live on the same database as another application (even another Symphony install!)</p>
<h5>Assets</h5>
<p>Meta Keys requires some custom Javascript and CSS so I've also created an <code>assets</code> directory in the extension folder. I only have two assets for Meta Keys, <code>field_metakeys.publish.js</code> and <code>field_metakeys.publish.css</code>, which follow another <a href="http://symphony-cms.com/discuss/blog/entry/a-guide-to-javascript-for-symphony-22/">Symphony naming convention</a>. This naming convention is purely aesthetics, but it an important one and can help developers when debugging their own extensions and looking for any potential conflicts.</p>
<h4><code>field.metakeys.php</code></h4>
<p>Now for the fun part, defining your Field! I like to break up my extensions field into some logical sections to keep maintenance easy and makes the code readable, even if I'm lazy and omit comments. For Meta Keys, I've used Setup, Utilities, Settings, Input, Output and Filtering as my sections, but your free to use whatever you like.</p>
<p>Similar to the extension driver, your Field class will extend the base <code>Field</code> class and requires a <a href="https://github.com/brendo/field_metakeys/blob/master/fields/field.metakeys.php#L5"><code>field{handle}</code> naming convention</a>. This convention allows Symphony to load Meta Keys from the filesystem using the <code>FieldManager</code>.</p>
<h5>Setup</h5>
<h6><code>__construct()</code></h6>
<p>The <a href="https://github.com/brendo/field_metakeys/blob/master/fields/field.metakeys.php#L7-15"><code>__construct()</code></a> function is your first chance to add some default settings, using the <code>set()</code> function of the Field class. I've set Meta Keys to (by default) not be required (but it has the ability to be), not be shown in the entries table and to default to the sidebar of Entry forms. The values from the <code>set()</code> function are stored in <code>sym_fields_metakeys</code>, which we created in the <code>install()</code> function in the extension driver, and is executed when a developer enables your extension.</p>
<h6><code>createTable()</code></h6>
<p>The <code>createTable()</code> function is executed when a new instance of your Field is added to a Section and it is responsible for creating the entry data tables for the Field. The table name for the entry data should be <code>sym_entries_data_%d</code>, where <code>%d</code> will be the id (<code>field_id</code>) of the current Field instance.</p>
<p>This table schema will hold the data that a user enters from the Entry creation page, and the only required columns are <code>id</code> and <code>entry_id</code>. You may like to take some time add a Field to a Section and inspect what happens in the <code>sym_fields</code> table. It's important that you understand the distinction between your settings table, and the entry data table. Looking at the Field's <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.field.php#1066-1083">default <code>createTable()</code> function</a> may also prove useful.</p>
<p>After defining your entry table schema, it's commonplace to list some functions that act as feature toggles for your Field. For MetaKeys, I've said that it <code>canFilter()</code> and <code>allowDatasourceParamOutput()</code>, but I've turned off <code>prePopulate</code>. A complete listing of these 'features' can be found by reading through the <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.field.php#165-309"><code>Field</code> class</a>. For example, you may wish to turn off Sorting for your Field (<code>isSortable()</code>), or not allow it to be Grouped (<code>allowDatasourceOutputGrouping</code>) or may it unique, aka, one Field per section (<code>mustBeUnique()</code>).</p>
<h5>Settings</h5>
<h6><code>displaySettingsPanel()</code></h6>
<p>The Section Editor allows a user to customise your Field for their use in a Section. To do this, you can provide your own HTML through the <code>displaySettingsPanel()</code> function. It is recommended to call <code>parent::displaySettingsPanel()</code> first, which will build a wrapper for you to add your HTML in. Symphony abstracts HTML using the <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.xmlelement.php"><code>XMLElement</code></a> class, which mimics PHP's DOMDocument functionality to a degree. The Symphony <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.widget.php"><code>Widget</code></a> class provides a set of convenience functions to allow you to build common HTML elements rapidly. </p>
<p>Symphony has some <a href="http://symphony-cms.com/discuss/blog/entry/a-guide-to-css-and-layout-changes-in-symphony-22/">CSS conventions</a> that allows your extensions to look as native as possible. Meta Keys makes use of one of the most common conventions, the two column layout using the <code>group</code> class, eg. <code>&lt;div class='group'&gt;</code> wrapper around two block DOM elements. There is also no need to replicate the logic to build some common setting interfaces, with functions such as <code>appendRequiredCheckbox()</code>, <code>appendShowColumnCheckbox()</code> and <code>buildValidationSelect()</code> all available to use. You can access the default settings of your Field by using <code>$this-&gt;get({setting-name})</code>. This is especially important for when a developer will come to edit your Field in the Section Editor, as it will prepopulate the field values with the current settings.</p>
<p>Meta Keys doesn't do anything unusual in the settings panel but add an additional input field so that a user can specify some default keys that will populate the Field on new entry creation, and provide a validator so that developers can ensure keys/values are entered that match a particular format. Because these setting's are specific to Meta Keys, it will not be stored in the <code>sym_fields</code> table, and instead will be in my Field's own settings table, <code>sym_field_metakeys</code>. These default keys are saved in the <code>default_keys</code> column, with the validator rule saved in <code>validator</code>.</p>
<h6><code>commit()</code></h6>
<p>Following <code>displaySettingsPanel()</code> is the <code>commit()</code> function, which is responsible for saving the field settings in the Database. Any core Symphony settings will be saved as a new row in the <code>sym_fields</code> table by simply calling the parent commit function, <code>parent::commit()</code>. If this is successful, you can use the rest of the <code>commit()</code> function to save the custom settings into your settings table, in this case, <code>sym_fields_metakeys</code>. The <code>field_id</code> of your Field instance is generated from the <code>auto_increment</code> index in the <code>sym_fields</code> table, and is accessible via <code>$this-&gt;get('id')</code> after the parent <code>commit()</code> function is called.</p>
<h5>Input</h5>
<p>Now that you've allowed your Field to be added to a Section, you may want to experiment and have a look at the database tables to see the above functions in action. The next focus should be allowing a user to add data into your Field, and how your field is rendered in the Entry Creation form. Enter <code>displayPublishPanel()</code>..</p>
<h6><code>displayPublishPanel()</code></h6>
<p>This function requires you to build out form elements using <code>XMLElement</code>. The first parameter of <code>displayPublishPanel()</code> is a <code>XMLElement</code> wrapper, which by default is <code>&lt;div class='field field-{field-handle}&gt;</code>. If the field is marked as required, a <code>required</code> class is also added. The <code>field-handle</code> is the handlized version of the <code>$field-&gt;name</code> (which we set in the Field constructor ;)), which is available via <code>$this-&gt;handle()</code>. These classes allow you to apply CSS only to your field, and not every field in the section. Additional parameters passed to the function include an associative array of the entry <code>$data</code>, an <code>$error</code> (that have occurred while trying to save), <code>$prefix</code> and <code>$postfix</code> (which I have no idea about, it seems to stem from early editions of Symphony and is commonly left as <code>null</code> these days) and in the instance of an Edit Entry form, the current <code>$entry_id</code>.</p>
<p>You may want to have a browse over the <a href="https://github.com/brendo/field_metakeys/blob/master/fields/field.metakeys.php#L157-197">Meta Keys <code>displayPublishPanel()</code> function</a> to get a quick idea of how to interact with <code>XMLElement</code> and the <code>Widget</code> class. Something to note here is the use of <code>$this-&gt;get('element_name')</code> which provides a handlized version of the Label of your field (set by the Developer when they added it to the Section) and is used so the form knows what field the data is meant for. You can see this in action in my utility <a href="https://github.com/brendo/field_metakeys/blob/master/fields/field.metakeys.php#L66-85"><code>buildPair()</code> function</a></p>
<p>To inject the custom CSS and JS for Meta Keys, the <code>displayPublishPanel()</code> function calls the <a href="https://github.com/brendo/field_metakeys/blob/master/extension.driver.php#L69"><code>appendAssets()</code> function</a>, which is defined as a static utility function in the <code>extension.driver.php</code> file. Something to note here is the use of the <code>$duplicate</code> parameter with the <code>addScriptToHead()</code> and <code>addStylesheetToHead()</code> functions. By setting this to <code>false</code>, this will prevent Meta Key's assets from being injected into the head for every instance of the field in the current section. You may want to note the explicit check for the presence of the <code>Administration</code> class, and that <code>$Page</code> is an instance of the <code>HTMLPage</code> class before trying to append the resources to the page. We can only add Javascript and CSS in the Administration context (and it's only possible in this context as the <code>addScriptToHead()</code> and <code>addStylesheetToHead()</code> functions don't exist in the Frontend context), hence the check. This is check ensures your function will not throw an error if it is called in the <code>Frontend</code> context (Section Schemas does this to generate a representation of your Field for use on Frontend fields). </p>
<h6><code>checkPostFieldData()</code></h6>
<p>Once you have displayed your interface, the next thing you'll want to do is check any data that the user tries to save using <code>checkPostFieldData()</code>. This function is given an associative array of the data for this field instance only, so essentially <code>$_POST['fields'][$this-&gt;get('element_name')</code>, to perform validation logic on. If the data passed is correct, this function should return <code>Field::OK</code>, otherwise there is a selection of Field constants that can be returned, which will slightly affect the error message returned. The most common are <code>Field::__MISSING_FIELDS__</code> or <code>Field::__INVALID_FIELDS__</code>. Check the <a href="https://github.com/symphonycms/symphony-2/blob/integration/symphony/lib/toolkit/class.field.php#15-58">Field class</a> for further error constants that you can use. Meta Keys checks to see if the current instance is required, that data has been received, and if any validator rules have been set before returning Field status.</p>
<h6><code>processRawFieldData()</code></h6>
<p>Should the data be ok, <code>processRawFieldData()</code> gives you the chance to map the <code>$_POST</code> data to the Field's database table, (<code>sym_entries_data_%d</code>). While this function is pretty self explanatory, the <code>$simulate</code> parameter often is a point of confusion for developers. The idea behind this parameter is to allow your function to 'almost' save the raw data, but not make any lasting changes (ie. doesn't commit the data to the database). Meta Keys doesn't need to simulate anything (and the majority of fields don't), so the parameter is just ignored within the function. The expected result from this function is an associative array, with the key's being the table columns described in the <code>Field-&gt;createTable()</code> function. Should your field like Meta Keys need to add multiple rows, you can use a multidimensional array, with numerical indexes as shown below.</p>
<p><a href="http://www.flickr.com/photos/bloodbone/5423557575/"><img src="http://farm6.static.flickr.com/5300/5423557575_426a4afe0a.jpg" alt="processRawFieldData" /></a></p>
<h6><code>getExampleFormMarkup()</code></h6>
<p>The last function for this block, <code>getExampleFormMarkup()</code> is a way for you to provide some documentation about how the markup for Frontend forms should be created if a user wants an Event to populate your field. You can add anything in here, using the <code>XMLElement</code> class, which will be shown to a user when they save their Event in the backend.</p>
<h5>Output</h5>
<p>So the user has saved some data for your extension, now it's up to you to format it so that it can be useful on the Frontend of the site!</p>
<h6><code>fetchIncludableElements()</code></h6>
<p>Some field extensions can offer multiple ways for the data to be formatted in a datasource. This concept is known as 'output modes', and is usually shown by <code>Field Name : {mode}</code>. The <code>fetchIncludableElements()</code> function allows your extension to show the different modes that is has to offer. Meta Keys offers two modes for output, so this function returns an array of <code>$this-&gt;get('element-name')</code> and <code>$this-&gt;get('element-name'): named-keys</code>.</p>
<p><a href="http://www.flickr.com/photos/bloodbone/5424213638/"><img src="http://farm6.static.flickr.com/5299/5424213638_8db5311caf.jpg" alt="Included Elements" /></a></p>
<h6><code>appendFormattedElement()</code></h6>
<p>The <code>appendFormattedElement()</code> is called every time your Field is included in a Datasource and is executed on the Frontend. It is given a <code>$wrapper</code> parameter, which is an XMLElement for this datasource, the <code>$data</code> for this datasource, a boolean <code>$encode</code> parameter, the <code>$mode</code> and the current <code>$entry_id</code>. It's important to note that <code>$data</code> contains data for a single entry, and that this function is called <code>x</code> times for the number of entries in the datasource. The <code>$mode</code> parameter will be the string after the <code>:</code> from <code>fetchIncludableElements()</code>. In the case where your Field only provides one output mode, this will be <code>null</code>. Meta Keys uses the <code>$mode</code> parameter to switch between the two output modes. Below is an example of the two output modes that Meta Keys provides.</p>
<p><a href="http://www.flickr.com/photos/bloodbone/5423612695/"><img src="http://farm6.static.flickr.com/5012/5423612695_8f5c4bd6db.jpg" alt="Two Output Modes" /></a></p>
<h6><code>getParameterPoolValue()</code></h6>
<p>Almost there! <code>getParameterPoolValue()</code> allows you to format your entry specifically for use as a Datasource Output param. It is given an array of data for the entire datasource as an associative array that represents your table schema (from the entry table, <code>sym_entries_data_%d</code>). At this stage, Meta Keys is just going to output the keys that are used in entry. The only real thing to note here is that a string must be returned.</p>
<p><a href="http://www.flickr.com/photos/bloodbone/5423654631/"><img src="http://farm6.static.flickr.com/5060/5423654631_73f7830968.jpg" alt="Example array for getParameterPoolValue" /></a></p>
<h6><code>prepareTableValue()</code></h6>
<p><code>prepareTableValue()</code> is used in the Symphony backend context only. The result of this function is what will be displayed on the entries table should your field be shown (Show Column in the Section Editor). Meta Keys makes use of <code>parent::prepareTableValue()</code> to do most of the heavy lifting here. This function differs from <code>getParameterPoolValue()</code> in that the <code>$data</code> array is for one entry, not every entry otherwise the same logic applies in that a string of data needs to be created to be passed onto the parent function. The parent function makes use of Symphonys <code>cell_truncation_length</code> value in the <code>config.php</code>, which extracts a certain number of characters from your value. By default, Symphony installs with this is set to 75. </p>
<p>The <code>$link</code> parameter will contain an <code>XMLElement</code> wrapper, which allows a user to edit the current entry, should your Field be the first visible column in the entries table, otherwise it will default to null.</p>
<h5>Filtering</h5>
<p>The final function in the Meta Keys field class is <code>buildDSRetrivalSQL()</code> and this one is responsible for generating the SQL to filter the entries for a datasource. The <code>$data</code> parameter is an array of the filters for your Field. Meta Keys allows developers to filter the field with a couple of prefixes, <code>value:</code> and <code>key-equals</code>, so the logic looks for the filters to start with either of these, before falling back to a generic filter SQL. For Meta Keys, the <code>value</code> prefix allows a developer to filter by the value of a Key, ie. <code>value: red</code> will get any entries where one of the Meta Keys contains the value 'red'. <code>key-equals</code> is more specific, allowing a developer to specify that Key and the Value that should be filtered on, ie. <code>key-equals: colour=red</code>. No prefix just falls back to looking for any <code>key</code> that is <code>red</code>.</p>
<p>To build the SQL required, this function is given <code>$joins</code> and <code>$where</code> parameters by reference, which allow you to add on your SQL. The goal of this SQL is to return the entry id's of that match all the datasource filters, so your join will be on <code>sym_entries</code>, which has been prefixed to <code>e</code>.</p>
<p><code>
    $joins .= "
        LEFT JOIN
            <code>sym_entries_data_{$field_id}</code> AS t{$field<em>id}</em>{$this-><em>key}
        ON
            (e.id = t{$field</em>id}<em>{$this-></em>key}.entry_id)
    ";
</code></p>
<p>Your SQL should take into account the fact that there maybe multiple filters on this field, so using <code>$this-&gt;_key</code> will allow a new table alias to be created everytime this occurs. <code>$this-&gt;key</code> is a integer, and is generally incremented each time the <code>buildDSRetrivalSQL()</code> function is called. Should you wish to sanitize the filters, and you should, the Field class provides the <code>cleanValue()</code> function to do that :)</p>
<h4>Additional Notes</h4>
<h5>Github Repository naming</h5>
<p>Occasionally, people will run into some problems when cloning extensions from github because the repository is named slightly differently to the extension's directory. If your github repository is named differently to your extension directory, a default clone will checkout the repo name, which will cause the extension to not be loaded, and the user to have to manually rename the directory to match the extension driver's class. This is necessary because Symphony loads some objects from the filesystem which relys on the following naming conventions:</p>
<ul>
<li>Repo: <strong>field_metakeys</strong></li>
<li>Folder: <strong>field_metakeys</strong></li>
<li>Extension Driver: extension_<strong>field_metakeys</strong></li>
</ul>
<h5>Why don't I use <code>Symphony::Engine()</code> ?</h5>
<p>Symphony 2.2 introduces <code>Symphony::Engine()</code>, which automatically provides an instance of the currently available context, whether that be Frontend or Administration. In the <code>appendAssets()</code> function, one might considered updating their code to use this new accessor, however in this situation, it is not possible to inject CSS and JS into the Frontend of a Symphony installation (imagine if that happened?!), so extension developers should always check explicitly for the Administration instance. <a href="http://symphony-cms.com/discuss/blog/entry/a-guide-to-accessor-changes-in-symphony-22/">This article</a> provides some detailed information about some accessor changes in Symphony 2.2.</p>
<h5>How to access the Symphony Database?</h5>
<p>The correct way for any extension to access the Symphony Database instance is through the accessor <code>Symphony::Database()</code>. It has been like this since Symphony 2.0.6.</p>
<h4>That's it!</h4>
<p>That's it for Meta Keys, I hope that's helped clean up some confusion and unravel a bit of mystery of Symphony Fields and extensions. There are still many functions left for you to discover that Meta Keys doesn't need, such as Sorting and Grouping, but I'll leave that as an exercise for you :) The Symphony 2.2 codebase is now fully documented using the PHPDoc syntax, so by all means, go forth, discover and learn!</p></body>
            <concepts>
                <item id="33156" handle="extension-file-structure" section-handle="concepts" section-name="Concepts">Extension File Structure</item>
                <item id="33071" handle="extensions" section-handle="concepts" section-name="Concepts">Extensions</item>
                <item id="33065" handle="fields" section-handle="concepts" section-name="Concepts">Fields</item>
                <item id="33159" handle="github" section-handle="concepts" section-name="Concepts">Github</item>
            </concepts>
            <date-modified time="09:46" weekday="7">2011-03-13</date-modified>
            <date-published time="09:46" weekday="7">2011-03-13</date-published>
            <title handle="creating-a-field-extension-for-symphony">Creating a Field Extension for Symphony</title>
        </entry>
    </learn-article-view>
</data>